import numpy as np
import rasterio
from rasterio.transform import from_gcps
from rasterio.control import GroundControlPoint
import imageio.v2 as imageio  # Use imageio.v2 to avoid deprecation warnings

def load_image(image_path: str) -> np.ndarray:
    """
    Loads a standard image (PNG, JPG) and prepares it for SFS.
    - Converts to grayscale if it's a color image.
    - Normalizes it to the [0, 1] range.
    """
    # Load image using imageio
    img_raw = imageio.imread(image_path)
    
    # If the image is color (RGB/RGBA), convert it to grayscale
    if img_raw.ndim == 3:
        # Handle RGB (3 channels) and RGBA (4 channels)
        if img_raw.shape[2] >= 3:
            # Use standard luminosity formula for grayscale conversion
            # L = 0.299*R + 0.587*G + 0.114*B
            rgb_weights = np.array([0.299, 0.587, 0.114])
            image_gray = np.dot(img_raw[...,:3], rgb_weights)
        else: # Should not happen with standard PNGs
            image_gray = img_raw[...,0]
    else:
        # Image is already grayscale
        image_gray = img_raw

    # Ensure data type is float for calculations
    image = image_gray.astype(np.float32)

    # Normalize image to have values between 0 and 1
    min_val, max_val = np.min(image), np.max(image)
    if max_val > min_val:
        image = (image - min_val) / (max_val - min_val)
    else:
        image = np.zeros_like(image)
        
    # Since PNG has no georeferencing, we only return the numpy array
    return image

def save_dem_as_geotiff(save_path: str, dem: np.ndarray, shape: tuple, config: dict):
    """
    Saves the DEM as a GeoTIFF file. This function is UNCHANGED.
    It works by taking the georeferencing data from the 'config' dictionary,
    not from the original input file.
    """
    height, width = shape
    corners = config["refined_corner_coords"]

    gcps = [
        GroundControlPoint(row=0, col=0, x=corners["upper_left"]["lon"], y=corners["upper_left"]["lat"]),
        GroundControlPoint(row=0, col=width-1, x=corners["upper_right"]["lon"], y=corners["upper_right"]["lat"]),
        GroundControlPoint(row=height-1, col=0, x=corners["lower_left"]["lon"], y=corners["lower_left"]["lat"]),
        GroundControlPoint(row=height-1, col=width-1, x=corners["lower_right"]["lon"], y=corners["lower_right"]["lat"]),
    ]
    transform = from_gcps(gcps)
    crs = "EPSG:4326"

    new_profile = {
        'driver': 'GTiff', 'height': dem.shape[0], 'width': dem.shape[1],
        'count': 1, 'dtype': dem.dtype, 'crs': crs, 'transform': transform,
        'nodata': -9999.0
    }

    with rasterio.open(save_path, 'w', **new_profile) as dst:
        dst.write(dem, 1)

def save_dem_as_obj(save_path: str, dem: np.ndarray):
    """
    Saves the DEM as a 3D Wavefront .obj file. This function is UNCHANGED.
    """
    height, width = dem.shape
    
    with open(save_path, 'w') as f:
        f.write("# 3D Model generated by Python SFS Photoclinometry\n")
        
        # Write vertices (v x y z)
        for i in range(height):
            for j in range(width):
                f.write(f"v {j} {height - 1 - i} {dem[i, j]}\n")
        
        # Write faces (f v1 v2 v3 v4)
        for i in range(height - 1):
            for j in range(width - 1):
                v1 = i * width + j + 1
                v2 = v1 + 1
                v3 = (i + 1) * width + j + 2
                v4 = v3 - 1
                f.write(f"f {v1} {v2} {v3} {v4}\n")